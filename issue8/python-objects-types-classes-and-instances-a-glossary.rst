对象、类型、类和实例——Python术语汇编
===================================

原文： `<http://eli.thegreenplace.net/2012/03/30/python-objects-types-classes-and-instances-a-glossary/>`_

译者：  Ruici Luo

当我在写另一篇文章 `internal of Python callables <http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/>`_ 时，我想到Python中的有些东西会拥有多个的名字。同时，某些名字有时候也会指代多个实体，其中哪一个实体是被隐式指定的需要根据上下文信息来判定。因此，为了今后写文章的方便，将这类命名法放在一个单独的地方是一个不错的主意。这样我就能够在任何讨论到这些主题的时候链接到这里，而不是一次又一次地解释他们。

特别地，我会先定义我所说的的类型、对象、类和实例。需要注意的是这里的依据是Python 3.x，当然大多数情况下也是适用于Python 2.x的[1]。

对象
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
对象是最容易定义的，Python的 `data model reference <http://docs.python.org/dev/reference/datamodel.html>`_ 中就有一个很漂亮的定义：

::

    对象是Python对数据的抽象。Python程序中的所有数据都通过对象以及对象之间的关系来表示。（在某种意义上，代码也是通过对象来表示的，这与冯诺依曼模型中的“存储程序计算机”是一致的）

    每一个对象都拥有id，类型和值

所以，Python中的一切事物都是对象。列表、42、模块、函数都是对象。Python字节码都是以对象的形式存在的。所有这些都拥有类型以及唯一的ID:

::

    >>> def foo(): pass
    ...
    >>> type(foo), id(foo)
    (<class 'function'>, 38110760)
    >>> type(foo.__code__), id(foo.__code__)
    (<class 'code'>, 38111680)

这样的“一切事物都是对象”的模型被CPython实现所支持。事实上，如果你阅读了CPython源代码，你就会注意到每上述提到的每一个实体都可以通过一个指向基结构体PyObject的指针来操作。

类型
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Python data model reference中的定义如下：

::

    对象的类型决定了对象所支持的操作（例如，它可以计算长度吗？）并且定义了该类型对象的可能取值。

所以，Python中的每一个对象都拥有类型，类型的信息可以通过调用内置函数type得到[2]；类型同样也是对象，所以他也有自己的类型——type。后面一条可能在你编写Python代码时并没有太大用处，但是它于理解CPython的内部机制有着巨大的作用：

::

    >>> type(42)
    <class 'int'>
    >>> type(type(42))
    <class 'type'>
    >>> type(type(type(42)))
    <class 'type'>

是啊，这就像一只一只一直驮着下去的乌龟群啊。（译者注：这段文字源自Stephen Hawking的《时间简史》开头一位著名科学家与老妇人的对话，这里意指type可以不停嵌套下去）

类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
过去，用户定义的类与内置类型之间是有区别的。但是从2.2版本以后，只要使用“新式”的类（2.x中继承于object的类，在3.x中是默认的），他们之间就不再有区别。本质上，类是Python提供的一种在代码中定义新的用户定义类型(user-defined type)的机制。

::

    >>> class Joe: pass
    ...
    >>> j = Joe()
    >>> type(j)
    <class '__main__.Joe'>

 使用这样的机制我们创建了一种新的用户定义类型——Joe。j是类Joe的一个实例，换句话说，j是一个对象，它的类型是Joe。

 就像其他类型一样，Joe本身也是一个对象并且拥有自己的类型。他的类型就是type：

 ::

    >>> type(type(j))
    <class 'type'>

术语“类”和“类型”就是两个名字对应同一概念的一个例子。为了避免这种混乱，当我意指类型(type)时我会使用"type"，而意指使用class关键字创建的新类型时，我会使用"user-defined class"。需要注意，当我们使用CPython的C API创建新类型，并不会提到class——因为我们仅仅创建了一个新的类型(type)，而不是类(class)。

实例
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
和类与类型之间存在歧义一样，”实例(instance)“和”对象(object)“也是同义的。用这种方式考虑：对象是类型的实例(objects are instances of types)。所以，“42是类型int的一个实例”和“42是一个int对象”是等价的。我经常互换使用“实例”和“对象”，有时候当我特指那些CPython实现的制品的对象时，我会使用“实例”来指代类的实际对象。另外一个显示使用术语“实例”的地方是像isinstance这样的内置函数以及特殊的__instancecheck__属性。

结论
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
就像我们看到的，在Python术语表里有两对意义大致接近的术语。类型和类是可以相互交换的概念，只要有可能我会更愿意使用类型，只有当使用关键字class创建的用户定义类型时才使用术语class。在我看来，“类型”是一个更好的术语，即使class概念被完全从Python中去除，Python也不会更糟糕。

类似地，对象和实例也是有着相同意义的术语，可能有微小的不同。有时候使用“实例”会更加方便（例如当明确地谈到某特定对象是某特定类型的实例时——“j是Joe的实例”），但有时候使用“对象”会更好（例如讨论CPython实现的内部机制时）

我真诚地希望这篇文章能让你从混乱中解脱出来。对我来说，当我在别的文章中提到这些可能不清楚或者有歧义的术语时，这里可以充当一个术语表的角色。

[1] 只要不考虑2.x中传统类的存在，即认为所有用户定义类都是继承于object的。

[2] 一个可以替代的选择是__class__属性
