How Python 3 Should Have Worked
===============================

作为一个普通的Python开发者,不免会碰到Python 2到3的版本转换不成功的问题。我经常会得到一些请求来让我写的库能够在Python 3版本中运行，但是对于如何升级的问题，当我尝试各各种各样的冲突建议时，并没有多少个可行的方案。

确实，当你看到新的3.x版本匆匆发布，但是却没有多少人来使用，不免会有些推测Python在这次艰难的转型中是否会倒下。那么我们如何来帮助它越过这道坎？

似乎我看到很多关于Python 3版本的讨论彻底的，未来的，崭新的版本特性，我们却忽视了升级的方法。在Python 2时代，我们有非常清楚的方法来应对版本更新。

- 在Python 2.a版本中， 加入了from __future__ import new _feature 语句，你就可以明确声明你想要使用的新特性来使用新功能。

- 在Python 2.b版本中， 默认加入了功能，你不需要在使用之前去声明future。

-  在Python 2.c版本中，当你在使用旧的方法时，将会产生警告，来告诉你或者是改变你的既有代码，或者是停止运行

- 在Python 2.d版本中，它确实停止了工作。

这种方法可能确实蛮凑效，但是我却不清楚为什么在3版本的转换中，却不是很凑效。它可能是只想表达。

- Python 2.x版本将会支持 from __future__ import python3

将这个加在文件的首部将会声明这是一个Python3文件，编译器将会正确的解析它。(我意识到这样可能会从python 2到3的升级将会是一个繁重的工作，但是最好维护一个稳定的代码库)

如果我想让我基于Python2的程序来使用Python3的模块，我只需要确认这些模块在头部有调用import。如果我想给我的模块发布一个可以在Python3上可以运行的新版本的话，我只需要声明这个程序只在Python 2.x和更高版本中运行(伴随着新的import语句)。如果项目比较大，我甚至可以一次性将版本升级到3，留下旧代码，直到一些人来修正这些琐碎。最重要的，我可以升级到3版本而不必等到所有的依赖都满足，直到有一个完整的方案来解决.


用户知道只有在不改变既有代码的情况下他们才会升级到2.x版本。开发者知道大家最终会升级到2.x所以他们丢掉了对之前版本的支持。但是自从2.x的代码也可以在3下兼容，他们开始编写和发布可以未来兼容的代码，最终大部分的代码将会在python 3工作，用户也会升级到3(2.x将会给一些残余的代码以警告)。最终我们可以丢掉对2.x的支持然后让所有的代码都能更好的兼容。


这不是一个激进的点子，这是Python 升级的既有方式。除非我们再次这样做，否则我不知道我们如何才能渡过这次艰难阶段。
